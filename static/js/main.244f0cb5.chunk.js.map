{"version":3,"sources":["LocalFileReader.js","AllocationUtils.js","ConfigPanel.js","Table.js","ResultsPanel.js","LeadAllocationHome.js","reportWebVitals.js","index.js"],"names":["LocalFileReader","props","handleOpenDialog","e","state","buttonRef","current","open","handleOnFileLoad","data","onFileLoad","handleOnError","err","file","inputElem","reason","console","log","handleOnRemoveFile","onFileRemove","handleRemoveFile","removeFile","React","createRef","ref","this","onError","noClick","noDrag","config","header","dynamicTyping","skipEmptyLines","onRemoveFile","style","display","flexDirection","marginBottom","type","onClick","disabled","borderRadius","marginLeft","marginRight","width","paddingLeft","paddingRight","borderWidth","borderStyle","borderColor","height","lineHeight","marginTop","paddingTop","name","Component","ALLOCATION_MODES","RoundRobin","id","description","allocationFunction","leads","courseAdvisors","updatedLeads","slice","updatedCourseAdvisors","map","advisor","newAdvisor","lastAllocatedId","domesticAdvisors","filter","portfolio","PORTFOLIOS","canadaAdvisors","leadIndex","lead","sortedAdvisors","sort","a","b","filteredAdvisors","isInWorkingHours","created","location","selectedAdvisor","length","leadId","allocateLead","RoundRobinUnconstrained","MostSuitableUnconstrained","i","validAdvisors","caNum","propensity","MostSuitableAggressive","isMatchingPortfolio","caIsInWorkingHours","totalAllotment","MostSuitableFixedAllotmentTolerance","parameters","allotmentTolerance","order","label","decayPerDay","cycleDecayDurationDays","decayPerCycle","allocateMostSuitableWithAllotmentLimit","MostSuitableAdvisorAllotmentTolerance","isPercentage","Number","simulationStartDate","clone","startOf","lastDailyDecayDate","lastCycleDecayDate","lowestAllotment","MAX_SAFE_INTEGER","currentDate","applyDecay","Math","min","currentAllotment","allotmentCapA","allotmentLimit","allotmentCapB","remainingAllotmentA","remainingAllotmentB","MostSuitableProportionalAllotmentTolerance","PropensityAllotmentBalancedLinear","propensityWeighting","allotmentWeighting","availableAdvisors","propensityScore","averageAllotment","overallScoreA","overallScoreB","PropensityAllotmentBalancedProportional","cumulativePropensity","averagePropensity","calculateOverallScore","PropensityAllotmentBalancedProportionalPerCluster","caLeadsInCluster","leadsInCluster","caLeadsInCurrentCluster","cluster","calculateOverallScoreClustered","PropensityAllotmentDifficultyBalancedProportional","difficultyWeighting","totalCumulativeInherentAtLead","inherent","averageInherent","calculateOverallScoreWithDifficulty","runningInherent","TIMEZONES","Adelaide","startHour","endHour","timezoneOffsetFromAdelaide","Canada","tolerance","allotmentCap","allocatedCa","allotmentAtAllocation","assessedPropensity","allocatedPropensity","cycleDelayDays","diff","decayCyclesPassed","floor","totalDecayPercentage","add","dailyDecayDays","decayAmount","decayModifier","max","datetime","timezone","hourOfDay","hour","minute","dayOfWeek","subtract","day","effectiveEndHour","effectiveHourOfDay","ConfigPanel","allocationModeOptionElements","value","hidden","concat","Object","keys","mode","inputParameters","selectedMode","currentParameter","htmlFor","step","onChange","onParameterChange","onModeChange","target","Table","columns","useTable","getTableProps","getTableBodyProps","headerGroups","rows","prepareRow","headerGroup","getHeaderGroupProps","headers","column","getHeaderProps","render","row","getRowProps","cells","cell","getCellProps","PERCENT_FORMAT_PARAMS","maximumFractionDigits","ResultsPanel","CA_RESULTS_TABLE_COLUMNS","useMemo","Header","accessor","toLocaleString","undefined","varianceToInherent","predictedConversions","toFixed","OVERALL_RESULTS_TABLE_COLUMNS","averageVarianceToInherent","aggregatedResults","LeadAllocationHome","useState","leadData","setLeadData","setCourseAdvisors","setSelectedMode","setAggregatedResults","setInputParameters","leadExportData","setLeadExportData","resultSummaryExportData","setResultSummaryExportData","DATE_FORMAT","handleFileRemove","generateResults","result","leadNum","selectedPropensity","cumulativeInherent","totalLeads","updatedResult","generateExportData","adjustedLeads","newLead","format","caName","resultSummary","finalAllotment","unmodelledPropensityUsed","overallPropensity","push","getExportFilename","filename","moment","className","newCourseAdvisors","rowNum","newCa","handleCaDataLoad","salesforceId","Id","fieldNum","some","v","meta","fields","handleLeadDataLoad","handleModeChange","parameter","parameterOrder","updatedInputParameters","splice","handleParameterChange","runSimulation","bom","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.244f0cb5.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\n\r\nimport { CSVReader } from 'react-papaparse'\r\n\r\n\r\n\r\nexport default class LocalFileReader extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            buttonRef: React.createRef()\r\n        }\r\n    }    \r\n    \r\n  handleOpenDialog = (e) => {\r\n    // Note that the ref is set async, so it might be null at some point\r\n    if (this.state.buttonRef.current) {\r\n      this.state.buttonRef.current.open(e)\r\n    }\r\n  }\r\n\r\n  handleOnFileLoad = (data) => {\r\n    return this.props.onFileLoad(data);\r\n  }\r\n\r\n  handleOnError = (err, file, inputElem, reason) => {\r\n    console.log(err)\r\n  }\r\n\r\n  handleOnRemoveFile = (data) => {\r\n    return this.props.onFileRemove();\r\n  }\r\n\r\n  handleRemoveFile = (e) => {\r\n    // Note that the ref is set async, so it might be null at some point\r\n    if (this.state.buttonRef.current) {\r\n        this.state.buttonRef.current.removeFile(e)\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <CSVReader\r\n        ref={this.state.buttonRef ? this.state.buttonRef : null}\r\n        onFileLoad={this.handleOnFileLoad}\r\n        onError={this.handleOnError}\r\n        noClick\r\n        noDrag\r\n        config={\r\n            {\r\n                header: true,\r\n                dynamicTyping: true,\r\n                skipEmptyLines: true,\r\n            }\r\n        }\r\n        onRemoveFile={this.handleOnRemoveFile}\r\n      >\r\n        {({ file }) => (\r\n          <aside\r\n            style={{\r\n              display: 'flex',\r\n              flexDirection: 'row',\r\n              marginBottom: 10\r\n            }}\r\n          >\r\n            <button\r\n              type='button'\r\n              onClick={this.handleOpenDialog}\r\n              disabled={this.props.disabled}\r\n              style={{\r\n                borderRadius: 0,\r\n                marginLeft: 0,\r\n                marginRight: 0,\r\n                width: '40%',\r\n                paddingLeft: 0,\r\n                paddingRight: 0\r\n              }}\r\n            >\r\n              Browse file\r\n            </button>\r\n            <div\r\n              style={{\r\n                borderWidth: 1,\r\n                borderStyle: 'solid',\r\n                borderColor: '#ccc',\r\n                height: 45,\r\n                lineHeight: 2.5,\r\n                marginTop: 5,\r\n                marginBottom: 5,\r\n                paddingLeft: 13,\r\n                paddingTop: 3,\r\n                width: '60%'\r\n              }}\r\n            >\r\n              {file && file.name}\r\n            </div>\r\n            <button\r\n              style={{\r\n                borderRadius: 0,\r\n                marginLeft: 0,\r\n                marginRight: 0,\r\n                paddingLeft: 20,\r\n                paddingRight: 20\r\n              }}\r\n              onClick={this.handleRemoveFile}\r\n            >\r\n              Remove\r\n            </button>\r\n          </aside>\r\n        )}\r\n      </CSVReader>\r\n    )\r\n  }\r\n}","\r\n\r\nexport const ALLOCATION_MODES = {\r\n    RoundRobin: {\r\n        id: 0,\r\n        name: \"Round Robin\",\r\n        description: \"Allocates leads one by one to each available CA\",\r\n        allocationFunction: allocateRoundRobin,\r\n    },\r\n    RoundRobinUnconstrained: {\r\n        id: 1,\r\n        name: \"Round Robin (Unconstrained)\",\r\n        description: \"Allocates leads one by one to each CA, irrespective of portfolio or working hours\",\r\n        allocationFunction: allocateRoundRobinUnconstrained,\r\n    },\r\n    MostSuitableUnconstrained: {\r\n        id: 2,\r\n        name: \"Most Suitable (Unconstrained)\",\r\n        description: \"Allocates leads always to the CA with the highest likelihood of conversion. Ignores portfolio and working hours constraints\",\r\n        allocationFunction: allocateMostSuitableUnconstrained,\r\n    },\r\n    MostSuitableAggressive: {\r\n        id: 3,\r\n        name: \"Most Suitable (Aggressive)\",\r\n        description: \"Allocates leads always to the CA with the highest likelihood of conversion. Uses lowest current allotment as a tiebreaker\",\r\n        allocationFunction: allocateMostSuitableAggressive,\r\n    },\r\n    MostSuitableFixedAllotmentTolerance: {\r\n        id: 4,\r\n        name: \"Most Suitable (Fixed allotment tolerance)\",\r\n        description: \"Allocates leads to the CA with the highest likelihood of conversion, so long as their allotment is not a \" + \r\n            \"given number of leads more than any other CA currently available. If all available CAs are outside of this tolerance, \" +\r\n            \"picks the one with the fewest leads currently allotted\",\r\n        parameters: {\r\n            allotmentTolerance: {\r\n                order: 0,\r\n                label: \"Allotment Tolerance\",\r\n            },\r\n            decayPerDay: {\r\n                order: 1,\r\n                label: \"Lead decay per day\",\r\n            },\r\n            cycleDecayDurationDays: {\r\n                order: 2,\r\n                label: \"Days per sales cycle\",\r\n            },\r\n            decayPerCycle: {\r\n                order: 3,\r\n                label: \"Lead decay per sales cycle (%)\",\r\n            },\r\n        },\r\n        allocationFunction: allocateMostSuitableFixedAllotmentLimit,\r\n    },\r\n    MostSuitableAdvisorAllotmentTolerance: {\r\n        id: 5,\r\n        name: \"Most Suitable (Per-CA allotment tolerance)\",\r\n        description: \"Allocates leads to the CA with the highest likelihood of conversion, so long as their allotment is not a \" + \r\n            \"given number of leads more than any other CA currently available. If all available CAs are outside of this tolerance, \" +\r\n            \"picks the one with the fewest leads currently allotted\",\r\n        parameters: {\r\n            decayPerDay: {\r\n                order: 0,\r\n                label: \"Lead decay per day\",\r\n            },\r\n            cycleDecayDurationDays: {\r\n                order: 1,\r\n                label: \"Days per sales cycle\",\r\n            },\r\n            decayPerCycle: {\r\n                order: 2,\r\n                label: \"Lead decay per sales cycle (%)\",\r\n            },\r\n        },\r\n        allocationFunction: allocateMostSuitableAdvisorAllotmentLimit,\r\n    },\r\n    MostSuitableProportionalAllotmentTolerance: {\r\n        id: 6,\r\n        name: \"Most Suitable (Proportional allotment tolerance)\",\r\n        description: \"Allocates leads to the CA with the highest likelihood of conversion, so long as their allotment is not a \" + \r\n            \"number of leads more than any other CA currently available by a given percentage. If all available CAs are outside of this tolerance, \" +\r\n            \"picks the one with the fewest leads currently allotted\",\r\n        parameters: {\r\n            allotmentTolerance: {\r\n                order: 0,\r\n                label: \"Allotment Tolerance (%)\",\r\n            },\r\n            decayPerDay: {\r\n                order: 1,\r\n                label: \"Lead decay per day\",\r\n            },\r\n            cycleDecayDurationDays: {\r\n                order: 2,\r\n                label: \"Days per sales cycle\",\r\n            },\r\n            decayPerCycle: {\r\n                order: 3,\r\n                label: \"Lead decay per sales cycle (%)\",\r\n            },\r\n        },\r\n        allocationFunction: allocateMostSuitableProportionalAllotmentLimit,\r\n    },\r\n    PropensityAllotmentBalancedLinear: {\r\n        id: 7,\r\n        name: \"Propensity vs. Allotment Balance (Linear)\",\r\n        description: \"Allocates leads to the CA based on both their propensity and their current allotment. \" +\r\n        \"Higher propensity will increase the preference given to the CA but a higher allotment will decrease it. \" + \r\n        \"Weightings are used to control the relative importance of choosing most suitable vs. balancing allotment\",\r\n        parameters: {\r\n            propensityWeighting: {\r\n                order: 0,\r\n                label: \"Propensity weighting\",\r\n            },\r\n            allotmentWeighting: {\r\n                order: 1,\r\n                label: \"Allotment weighting\",\r\n            },\r\n            decayPerDay: {\r\n                order: 2,\r\n                label: \"Lead decay per day\",\r\n            },\r\n            cycleDecayDurationDays: {\r\n                order: 3,\r\n                label: \"Days per sales cycle\",\r\n            },\r\n            decayPerCycle: {\r\n                order: 4,\r\n                label: \"Lead decay per sales cycle (%)\",\r\n            },\r\n        },\r\n        allocationFunction: allocatePropensityAllotmentBalancedLinear,\r\n    },\r\n    PropensityAllotmentBalancedProportional: {\r\n        id: 8,\r\n        name: \"Propensity vs. Allotment Balance (Proportional)\",\r\n        description: \"Allocates leads to the CA based on both their propensity and their current allotment. \" +\r\n        \"Higher propensity proportionally relative to the average will increase the preference given to the CA but a higher allotment will decrease it. \" + \r\n        \"Weightings are used to control the relative importance of choosing most suitable vs. balancing allotment\",\r\n        parameters: {\r\n            propensityWeighting: {\r\n                order: 0,\r\n                label: \"Propensity weighting\",\r\n            },\r\n            allotmentWeighting: {\r\n                order: 1,\r\n                label: \"Allotment weighting\",\r\n            },\r\n            decayPerDay: {\r\n                order: 2,\r\n                label: \"Lead decay per day\",\r\n            },\r\n            cycleDecayDurationDays: {\r\n                order: 3,\r\n                label: \"Days per sales cycle\",\r\n            },\r\n            decayPerCycle: {\r\n                order: 4,\r\n                label: \"Lead decay per sales cycle (%)\",\r\n            },\r\n        },\r\n        allocationFunction: allocatePropensityAllotmentBalancedProportional,\r\n    },\r\n    PropensityAllotmentBalancedProportionalPerCluster: {\r\n        id: 9,\r\n        name: \"Propensity vs. Allotment Balance (Proportional per Cluster)\",\r\n        description: \"Allocates leads to the CA based on both their propensity and their current allotment. \" +\r\n        \"Higher propensity proportionally relative to the average will increase the preference given to the CA but a higher allotment of leads from the same cluster will decrease it. \" + \r\n        \"Weightings are used to control the relative importance of choosing most suitable vs. balancing allotment\",\r\n        parameters: {\r\n            propensityWeighting: {\r\n                order: 0,\r\n                label: \"Propensity weighting\",\r\n            },\r\n            allotmentWeighting: {\r\n                order: 1,\r\n                label: \"Allotment weighting\",\r\n            },\r\n            // decayPerDay: {\r\n            //     order: 2,\r\n            //     label: \"Lead decay per day\",\r\n            // },\r\n            // cycleDecayDurationDays: {\r\n            //     order: 3,\r\n            //     label: \"Days per sales cycle\",\r\n            // },\r\n            // decayPerCycle: {\r\n            //     order: 4,\r\n            //     label: \"Lead decay per sales cycle (%)\",\r\n            // },\r\n        },\r\n        allocationFunction: allocatePropensityAllotmentBalancedProportionalPerCluster,\r\n    },\r\n    PropensityAllotmentDifficultyBalancedProportional: {\r\n        id: 10,\r\n        name: \"Propensity vs. Allotment vs. Difficulty Balance (Proportional)\",\r\n        description: \"Allocates leads to the CA based on their propensity, their current allotment, and the proportion of 'difficult' leads they are getting. \" +\r\n        \"Higher propensity proportionally relative to the average will increase the preference given to the CA but a higher allotment will decrease it. \" +\r\n        \"If the CA has been receiving a higher number of leads that inherently convert at a low likelihood, they will be increasingly preferred to get higher likelihood leads\" + \r\n        \"Weightings are used to control the relative importance of choosing most suitable vs. balancing allotment\",\r\n        parameters: {\r\n            propensityWeighting: {\r\n                order: 0,\r\n                label: \"Propensity weighting\",\r\n            },\r\n            allotmentWeighting: {\r\n                order: 1,\r\n                label: \"Allotment weighting\",\r\n            },\r\n            difficultyWeighting: {\r\n                order: 2,\r\n                label: \"Difficulty weighting\",\r\n            },\r\n            decayPerDay: {\r\n                order: 3,\r\n                label: \"Lead decay per day\",\r\n            },\r\n            cycleDecayDurationDays: {\r\n                order: 4,\r\n                label: \"Days per sales cycle\",\r\n            },\r\n            decayPerCycle: {\r\n                order: 5,\r\n                label: \"Lead decay per sales cycle (%)\",\r\n            },\r\n        },\r\n        allocationFunction: allocatePropensityAllotmentDifficultyBalancedProportional,\r\n    },\r\n}\r\n\r\nconst PORTFOLIOS = {\r\n    Domestic: \"Domestic\",\r\n    Canada: \"Canada\",\r\n}\r\n\r\nconst TIMEZONES = {\r\n    Adelaide: {\r\n        startHour: 9,\r\n        endHour: 17,\r\n        timezoneOffsetFromAdelaide: 0,\r\n    },\r\n    Canada: {\r\n        startHour: 22.5,\r\n        endHour: 6.5,\r\n        timezoneOffsetFromAdelaide: 13.5,\r\n    }\r\n}\r\n\r\n\r\nfunction allocateRoundRobin(leads, courseAdvisors) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.map((advisor) => {\r\n        let newAdvisor = {...advisor};\r\n        newAdvisor.lastAllocatedId = -1;\r\n        return newAdvisor;\r\n    });\r\n\r\n    let domesticAdvisors = updatedCourseAdvisors.filter((advisor) => (\r\n        (advisor.portfolio === PORTFOLIOS.Domestic)\r\n    ));\r\n    let canadaAdvisors = updatedCourseAdvisors.filter((advisor) => (\r\n        (advisor.portfolio === PORTFOLIOS.Canada)\r\n    ));\r\n\r\n    for (let leadIndex = 0; leadIndex < leads.length; leadIndex++) {\r\n        let lead = updatedLeads[leadIndex];\r\n        let sortedAdvisors;\r\n        if (lead.portfolio === PORTFOLIOS.Domestic) {\r\n            sortedAdvisors = domesticAdvisors.sort((a,b) => a.lastAllocatedId - b.lastAllocatedId);\r\n        }\r\n        else if (lead.portfolio === PORTFOLIOS.Canada) {\r\n            sortedAdvisors = canadaAdvisors.sort((a,b) => a.lastAllocatedId - b.lastAllocatedId);\r\n        }\r\n\r\n        let filteredAdvisors = sortedAdvisors.filter((advisor) => isInWorkingHours(lead.created, advisor.location));\r\n        let selectedAdvisor = filteredAdvisors.length > 0 ? filteredAdvisors[0] : sortedAdvisors[0];\r\n\r\n        selectedAdvisor.lastAllocatedId = lead.leadId;\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n    }\r\n\r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocateRoundRobinUnconstrained(leads, courseAdvisors) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.map((advisor) => {\r\n        let newAdvisor = {...advisor};\r\n        newAdvisor.lastAllocatedId = -1;\r\n        return newAdvisor;\r\n    });\r\n\r\n    for (let leadIndex = 0; leadIndex < leads.length; leadIndex++) {\r\n        let lead = updatedLeads[leadIndex];\r\n        let sortedAdvisors = updatedCourseAdvisors.slice().sort((a,b) => a.lastAllocatedId - b.lastAllocatedId);;\r\n\r\n        let selectedAdvisor = sortedAdvisors[0];\r\n\r\n        selectedAdvisor.lastAllocatedId = lead.leadId;\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n    }\r\n\r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocateMostSuitableUnconstrained(leads, courseAdvisors) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.slice();\r\n\r\n    for (let i = 0; i < leads.length; i++) {\r\n        let lead = updatedLeads[i];        \r\n        let validAdvisors = updatedCourseAdvisors.slice();\r\n\r\n        for (let caNum = 0; caNum < validAdvisors.length; caNum++) {\r\n            let advisor = validAdvisors[caNum];\r\n            validAdvisors[caNum] = {\r\n                ...advisor, \r\n                propensity: lead.courseAdvisors[advisor.id].propensity,\r\n            }\r\n        }\r\n\r\n        validAdvisors.sort((a,b) => {\r\n            //only care about propensity. As this is an unrealistic simulation, tiebreakers are pointless\r\n            return b.propensity - a.propensity;\r\n        });\r\n\r\n        let selectedAdvisor = validAdvisors[0];\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n    }\r\n    \r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocateMostSuitableAggressive(leads, courseAdvisors) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.slice();\r\n\r\n    for (let i = 0; i < leads.length; i++) {\r\n        let lead = updatedLeads[i];        \r\n        let validAdvisors = updatedCourseAdvisors.filter((advisor) => (isMatchingPortfolio(advisor, lead)));\r\n\r\n        for (let caNum = 0; caNum < validAdvisors.length; caNum++) {\r\n            let advisor = validAdvisors[caNum];\r\n            let caIsInWorkingHours = isInWorkingHours(lead.created, updatedCourseAdvisors[advisor.id].location);\r\n            validAdvisors[caNum] = {\r\n                ...advisor, \r\n                propensity: lead.courseAdvisors[advisor.id].propensity,\r\n                isInWorkingHours: caIsInWorkingHours,\r\n            }\r\n        }\r\n\r\n        validAdvisors.sort((a,b) => {\r\n            //give firm precedence to those who are currently working\r\n            if (b.isInWorkingHours && !a.isInWorkingHours) {\r\n                return 1;\r\n            }\r\n            if (a.isInWorkingHours && !b.isInWorkingHours) {\r\n                return -1;\r\n            }\r\n            //otherwise pick the most suitable CA based on propensity\r\n            if (b.propensity !== a.propensity) {\r\n                return b.propensity - a.propensity;\r\n            }\r\n            //use allotment numbers as a tiebreaker\r\n            return a.totalAllotment - b.totalAllotment;\r\n        });\r\n\r\n        let selectedAdvisor = validAdvisors[0];\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n    }\r\n    \r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocateMostSuitableFixedAllotmentLimit(leads, courseAdvisors, parameters) {\r\n    return allocateMostSuitableWithAllotmentLimit(leads, courseAdvisors, parameters, false);\r\n}\r\n\r\n\r\nfunction allocateMostSuitableProportionalAllotmentLimit(leads, courseAdvisors, parameters) {\r\n    return allocateMostSuitableWithAllotmentLimit(leads, courseAdvisors, parameters, true);\r\n}\r\n\r\n\r\nfunction allocateMostSuitableWithAllotmentLimit(leads, courseAdvisors, parameters, isPercentage) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.slice();\r\n\r\n    //HACK: possibly not safe as this assumes that the parameters for both methods are in the same order\r\n    let tolerance = Number(parameters[ALLOCATION_MODES.MostSuitableFixedAllotmentTolerance.parameters.allotmentTolerance.order]);\r\n    if (isPercentage) {\r\n        tolerance = tolerance / 100;\r\n    }\r\n    const decayPerDay = Number(parameters[ALLOCATION_MODES.MostSuitableFixedAllotmentTolerance.parameters.decayPerDay.order]);\r\n    const cycleDecayDurationDays = Number(parameters[ALLOCATION_MODES.MostSuitableFixedAllotmentTolerance.parameters.cycleDecayDurationDays.order]);\r\n    const decayPerCycle = Number(parameters[ALLOCATION_MODES.MostSuitableFixedAllotmentTolerance.parameters.decayPerCycle.order]) / 100;\r\n    const simulationStartDate = leads[0].created.clone().startOf('date');\r\n\r\n    let lastDailyDecayDate = simulationStartDate.clone();\r\n    let lastCycleDecayDate = simulationStartDate.clone();\r\n\r\n    for (let i = 0; i < leads.length; i++) {\r\n        let lead = updatedLeads[i];\r\n        let lowestAllotment = Number.MAX_SAFE_INTEGER;\r\n        let currentDate = leads[i].created.clone().startOf('date');\r\n\r\n        lastDailyDecayDate = applyDecay(updatedCourseAdvisors, currentDate, lastCycleDecayDate, lastDailyDecayDate, cycleDecayDurationDays, decayPerCycle, decayPerDay);\r\n        \r\n        let validAdvisors = updatedCourseAdvisors.filter((advisor) => (isMatchingPortfolio(advisor, lead)));\r\n\r\n        for (let caNum = 0; caNum < validAdvisors.length; caNum++) {\r\n            let advisor = validAdvisors[caNum];\r\n            lowestAllotment = Math.min(advisor.currentAllotment, lowestAllotment);\r\n            \r\n            let caIsInWorkingHours = isInWorkingHours(lead.created, updatedCourseAdvisors[advisor.id].location);\r\n            validAdvisors[caNum] = {\r\n                ...advisor, \r\n                propensity: lead.courseAdvisors[advisor.id].propensity,\r\n                isInWorkingHours: caIsInWorkingHours,\r\n            }\r\n        }\r\n\r\n        let allotmentCap;\r\n        if (isPercentage) {  \r\n            allotmentCap = lowestAllotment + lowestAllotment * tolerance \r\n        }\r\n        else {\r\n            allotmentCap = lowestAllotment + tolerance;\r\n        }\r\n\r\n        validAdvisors.sort((a,b) => {\r\n            //give firm precedence to those who are currently working\r\n            if (b.isInWorkingHours && !a.isInWorkingHours) {\r\n                return 1;\r\n            }\r\n            if (a.isInWorkingHours && !b.isInWorkingHours) {\r\n                return -1;\r\n            }\r\n            //then firm prededence to those within the tolerance range for allotment\r\n            if (b.currentAllotment < allotmentCap && a.currentAllotment >= allotmentCap) {\r\n                return 1;\r\n            }\r\n            if (a.currentAllotment < allotmentCap && b.currentAllotment >= allotmentCap) {\r\n                return -1;\r\n            }\r\n            //picking the person least outside tolerance if both are\r\n            if (a.currentAllotment >= allotmentCap && b.currentAllotment >= allotmentCap && b.currentAllotment !== a.currentAllotment) {\r\n                return a.currentAllotment - b.currentAllotment;\r\n            }\r\n            //otherwise picking the most suitable CA based on propensity\r\n            if (b.propensity !== a.propensity) {\r\n                return b.propensity - a.propensity;\r\n            }\r\n            //use allotment numbers as a tiebreaker\r\n            return a.currentAllotment - b.currentAllotment;\r\n        });\r\n\r\n        let selectedAdvisor = validAdvisors[0];\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n    }\r\n\r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocateMostSuitableAdvisorAllotmentLimit(leads, courseAdvisors, parameters, isPercentage) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.slice();\r\n\r\n    const decayPerDay = Number(parameters[ALLOCATION_MODES.MostSuitableAdvisorAllotmentTolerance.parameters.decayPerDay.order]);\r\n    const cycleDecayDurationDays = Number(parameters[ALLOCATION_MODES.MostSuitableAdvisorAllotmentTolerance.parameters.cycleDecayDurationDays.order]);\r\n    const decayPerCycle = Number(parameters[ALLOCATION_MODES.MostSuitableAdvisorAllotmentTolerance.parameters.decayPerCycle.order]) / 100;\r\n    const simulationStartDate = leads[0].created.clone().startOf('date');\r\n\r\n    let lastDailyDecayDate = simulationStartDate.clone();\r\n    let lastCycleDecayDate = simulationStartDate.clone();\r\n\r\n    for (let i = 0; i < leads.length; i++) {\r\n        let lead = updatedLeads[i];\r\n        let lowestAllotment = Number.MAX_SAFE_INTEGER;\r\n        let currentDate = leads[i].created.clone().startOf('date');\r\n\r\n        lastDailyDecayDate = applyDecay(updatedCourseAdvisors, currentDate, lastCycleDecayDate, lastDailyDecayDate, cycleDecayDurationDays, decayPerCycle, decayPerDay);\r\n        \r\n        let validAdvisors = updatedCourseAdvisors.filter((advisor) => (isMatchingPortfolio(advisor, lead)));\r\n\r\n        for (let caNum = 0; caNum < validAdvisors.length; caNum++) {\r\n            let advisor = validAdvisors[caNum];\r\n            lowestAllotment = Math.min(advisor.currentAllotment, lowestAllotment);\r\n            \r\n            let caIsInWorkingHours = isInWorkingHours(lead.created, updatedCourseAdvisors[advisor.id].location);\r\n            validAdvisors[caNum] = {\r\n                ...advisor, \r\n                propensity: lead.courseAdvisors[advisor.id].propensity,\r\n                isInWorkingHours: caIsInWorkingHours,\r\n            }\r\n        }\r\n\r\n        validAdvisors.sort((a,b) => {\r\n            //give firm precedence to those who are currently working\r\n            if (b.isInWorkingHours && !a.isInWorkingHours) {\r\n                return 1;\r\n            }\r\n            if (a.isInWorkingHours && !b.isInWorkingHours) {\r\n                return -1;\r\n            }\r\n            let allotmentCapA = lowestAllotment + a.allotmentLimit;\r\n            let allotmentCapB = lowestAllotment + b.allotmentLimit;\r\n            let remainingAllotmentA = allotmentCapA - a.currentAllotment;\r\n            let remainingAllotmentB = allotmentCapB - b.currentAllotment;\r\n            //then firm prededence to those within the tolerance range for allotment\r\n            if (b.currentAllotment < allotmentCapB && a.currentAllotment >= allotmentCapA) {\r\n                return 1;\r\n            }\r\n            if (a.currentAllotment < allotmentCapA && b.currentAllotment >= allotmentCapB) {\r\n                return -1;\r\n            }\r\n            //picking the person least outside tolerance if both are\r\n            if (a.currentAllotment >= allotmentCapA && b.currentAllotment >= allotmentCapB && remainingAllotmentB !== remainingAllotmentA) {\r\n                return remainingAllotmentB - remainingAllotmentA;\r\n            }\r\n            //otherwise picking the most suitable CA based on propensity\r\n            if (b.propensity !== a.propensity) {\r\n                return b.propensity - a.propensity;\r\n            }\r\n            //use allotment numbers as a tiebreaker\r\n            return a.currentAllotment - b.currentAllotment;\r\n        });\r\n\r\n        let selectedAdvisor = validAdvisors[0];\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n    }\r\n\r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocatePropensityAllotmentBalancedLinear(leads, courseAdvisors, parameters) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.slice();\r\n\r\n    const propensityWeighting = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedLinear.parameters.propensityWeighting.order]);\r\n    const allotmentWeighting = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedLinear.parameters.allotmentWeighting.order]);\r\n    const decayPerDay = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedLinear.parameters.decayPerDay.order]);\r\n    const cycleDecayDurationDays = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedLinear.parameters.cycleDecayDurationDays.order]);\r\n    const decayPerCycle = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedLinear.parameters.decayPerCycle.order]) / 100;\r\n    const simulationStartDate = leads[0].created.clone().startOf('date');\r\n\r\n    let lastDailyDecayDate = simulationStartDate.clone();\r\n    let lastCycleDecayDate = simulationStartDate.clone();\r\n\r\n    for (let i = 0; i < leads.length; i++) {\r\n        let lead = updatedLeads[i];\r\n        let totalAllotment = 0;\r\n        let availableAdvisors = 0;\r\n        let currentDate = leads[i].created.clone().startOf('date');\r\n\r\n        lastDailyDecayDate = applyDecay(updatedCourseAdvisors, currentDate, lastCycleDecayDate, lastDailyDecayDate, cycleDecayDurationDays, decayPerCycle, decayPerDay);\r\n        \r\n        let validAdvisors = updatedCourseAdvisors.filter((advisor) => (isMatchingPortfolio(advisor, lead)));\r\n\r\n        for (let caNum = 0; caNum < validAdvisors.length; caNum++) {\r\n            let advisor = validAdvisors[caNum];\r\n            totalAllotment = totalAllotment + advisor.currentAllotment;\r\n            \r\n            let caIsInWorkingHours = isInWorkingHours(lead.created, updatedCourseAdvisors[advisor.id].location);\r\n            let propensityScore = lead.courseAdvisors[advisor.id].propensity * propensityWeighting;\r\n            availableAdvisors = caIsInWorkingHours ? availableAdvisors + 1 : availableAdvisors;\r\n\r\n            validAdvisors[caNum] = {\r\n                ...advisor, \r\n                propensityScore: propensityScore,\r\n                isInWorkingHours: caIsInWorkingHours,\r\n            }\r\n        }\r\n        \r\n        let averageAllotment;\r\n        if (availableAdvisors > 0) {\r\n            averageAllotment = totalAllotment / availableAdvisors;\r\n        }\r\n        else {\r\n            averageAllotment = totalAllotment / validAdvisors.length;\r\n        }\r\n\r\n        validAdvisors.sort((a,b) => {\r\n            //give firm precedence to those who are currently working\r\n            if (b.isInWorkingHours && !a.isInWorkingHours) {\r\n                return 1;\r\n            }\r\n            if (a.isInWorkingHours && !b.isInWorkingHours) {\r\n                return -1;\r\n            }\r\n\r\n            //Otherwise choosing the CA with the best overall score\r\n            let overallScoreA = a.propensityScore + (averageAllotment - a.currentAllotment) * allotmentWeighting;\r\n            let overallScoreB = b.propensityScore + (averageAllotment - b.currentAllotment) * allotmentWeighting;\r\n            if (overallScoreB !== overallScoreA) {\r\n                return overallScoreB - overallScoreA;\r\n            }\r\n\r\n            //use allotment numbers as a tiebreaker\r\n            return a.currentAllotment - b.currentAllotment;\r\n        });\r\n\r\n        let selectedAdvisor = validAdvisors[0];\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n    }\r\n\r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocatePropensityAllotmentBalancedProportional(leads, courseAdvisors, parameters) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.slice();\r\n\r\n    const propensityWeighting = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.propensityWeighting.order]);\r\n    const allotmentWeighting = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.allotmentWeighting.order]);\r\n    const decayPerDay = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.decayPerDay.order]);\r\n    const cycleDecayDurationDays = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.cycleDecayDurationDays.order]);\r\n    const decayPerCycle = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.decayPerCycle.order]) / 100;\r\n    const simulationStartDate = leads[0].created.clone().startOf('date');\r\n\r\n    let lastDailyDecayDate = simulationStartDate.clone();\r\n    let lastCycleDecayDate = simulationStartDate.clone();\r\n\r\n    for (let i = 0; i < leads.length; i++) {\r\n        let lead = updatedLeads[i];\r\n        let totalAllotment = 0;\r\n        let cumulativePropensity = 0;\r\n        let availableAdvisors = 0;\r\n        let currentDate = leads[i].created.clone().startOf('date');\r\n\r\n        lastDailyDecayDate = applyDecay(updatedCourseAdvisors, currentDate, lastCycleDecayDate, lastDailyDecayDate, cycleDecayDurationDays, decayPerCycle, decayPerDay);\r\n        \r\n        let validAdvisors = updatedCourseAdvisors.filter((advisor) => (isMatchingPortfolio(advisor, lead)));\r\n\r\n        for (let caNum = 0; caNum < validAdvisors.length; caNum++) {\r\n            let advisor = validAdvisors[caNum];\r\n            totalAllotment = totalAllotment + advisor.currentAllotment;\r\n            cumulativePropensity = cumulativePropensity + lead.courseAdvisors[advisor.id].propensity;\r\n            \r\n            let caIsInWorkingHours = isInWorkingHours(lead.created, updatedCourseAdvisors[advisor.id].location);\r\n            availableAdvisors = caIsInWorkingHours ? availableAdvisors + 1 : availableAdvisors;\r\n\r\n            validAdvisors[caNum] = {\r\n                ...advisor, \r\n                propensity: lead.courseAdvisors[advisor.id].propensity,\r\n                isInWorkingHours: caIsInWorkingHours,\r\n            }\r\n        }\r\n        \r\n        let averageAllotment;\r\n        let averagePropensity;\r\n        if (availableAdvisors > 0) {\r\n            averageAllotment = totalAllotment / availableAdvisors;\r\n            averagePropensity = cumulativePropensity / availableAdvisors;\r\n        }\r\n        else {\r\n            averageAllotment = totalAllotment / validAdvisors.length;\r\n            averagePropensity = cumulativePropensity / validAdvisors.length;\r\n        }\r\n\r\n        validAdvisors.sort((a,b) => {\r\n            //give firm precedence to those who are currently working\r\n            if (b.isInWorkingHours && !a.isInWorkingHours) {\r\n                return 1;\r\n            }\r\n            if (a.isInWorkingHours && !b.isInWorkingHours) {\r\n                return -1;\r\n            }\r\n\r\n            //Otherwise choosing the CA with the best overall score\r\n            let overallScoreA = calculateOverallScore(a, averagePropensity, averageAllotment, propensityWeighting, allotmentWeighting);\r\n            let overallScoreB = calculateOverallScore(b, averagePropensity, averageAllotment, propensityWeighting, allotmentWeighting);\r\n            if (overallScoreB !== overallScoreA) {\r\n                return overallScoreB - overallScoreA;\r\n            }\r\n\r\n            //use allotment numbers as a tiebreaker\r\n            return a.currentAllotment - b.currentAllotment;\r\n        });\r\n\r\n        let selectedAdvisor = validAdvisors[0];\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n    }\r\n\r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocatePropensityAllotmentBalancedProportionalPerCluster(leads, courseAdvisors, parameters) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.slice();\r\n\r\n    const propensityWeighting = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.propensityWeighting.order]);\r\n    const allotmentWeighting = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.allotmentWeighting.order]);\r\n    // const decayPerDay = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.decayPerDay.order]);\r\n    // const cycleDecayDurationDays = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.cycleDecayDurationDays.order]);\r\n    // const decayPerCycle = Number(parameters[ALLOCATION_MODES.PropensityAllotmentBalancedProportional.parameters.decayPerCycle.order]) / 100;\r\n    // const simulationStartDate = leads[0].created.clone().startOf('date');\r\n\r\n    // let lastDailyDecayDate = simulationStartDate.clone();\r\n    // let lastCycleDecayDate = simulationStartDate.clone();\r\n    let caLeadsInCluster = courseAdvisors.slice().map((advisor) => {\r\n        return {\r\n            ...advisor,\r\n            leadsInCluster: [],\r\n        };\r\n    });\r\n\r\n    for (let i = 0; i < leads.length; i++) {\r\n        let lead = updatedLeads[i];\r\n        let totalAllotment = 0;\r\n        let cumulativePropensity = 0;\r\n        let availableAdvisors = 0;\r\n        // let currentDate = leads[i].created.clone().startOf('date');\r\n\r\n        // lastDailyDecayDate = applyDecay(updatedCourseAdvisors, currentDate, lastCycleDecayDate, lastDailyDecayDate, cycleDecayDurationDays, decayPerCycle, decayPerDay);\r\n        \r\n        let validAdvisors = updatedCourseAdvisors.filter((advisor) => (isMatchingPortfolio(advisor, lead)));\r\n\r\n        for (let caNum = 0; caNum < validAdvisors.length; caNum++) {\r\n            let advisor = validAdvisors[caNum];\r\n            cumulativePropensity = cumulativePropensity + lead.courseAdvisors[advisor.id].propensity;\r\n            \r\n            let caIsInWorkingHours = isInWorkingHours(lead.created, updatedCourseAdvisors[advisor.id].location);\r\n            availableAdvisors = caIsInWorkingHours ? availableAdvisors + 1 : availableAdvisors;\r\n\r\n            let caLeadsInCurrentCluster = caLeadsInCluster[advisor.id].leadsInCluster[lead.cluster] ? caLeadsInCluster[advisor.id].leadsInCluster[lead.cluster] : 0;\r\n            totalAllotment = totalAllotment + caLeadsInCurrentCluster;\r\n\r\n            validAdvisors[caNum] = {\r\n                ...advisor, \r\n                propensity: lead.courseAdvisors[advisor.id].propensity,\r\n                isInWorkingHours: caIsInWorkingHours,\r\n                leadsInCluster: caLeadsInCurrentCluster,\r\n            }\r\n        }\r\n        \r\n        let averageAllotment;\r\n        let averagePropensity;\r\n        if (availableAdvisors > 0) {\r\n            averageAllotment = totalAllotment / availableAdvisors;\r\n            averagePropensity = cumulativePropensity / availableAdvisors;\r\n        }\r\n        else {\r\n            averageAllotment = totalAllotment / validAdvisors.length;\r\n            averagePropensity = cumulativePropensity / validAdvisors.length;\r\n        }\r\n\r\n        validAdvisors.sort((a,b) => {\r\n            //give firm precedence to those who are currently working\r\n            if (b.isInWorkingHours && !a.isInWorkingHours) {\r\n                return 1;\r\n            }\r\n            if (a.isInWorkingHours && !b.isInWorkingHours) {\r\n                return -1;\r\n            }\r\n\r\n            //Otherwise choosing the CA with the best overall score\r\n            let overallScoreA = calculateOverallScoreClustered(a, averagePropensity, averageAllotment, propensityWeighting, allotmentWeighting);\r\n            let overallScoreB = calculateOverallScoreClustered(b, averagePropensity, averageAllotment, propensityWeighting, allotmentWeighting);\r\n            if (overallScoreB !== overallScoreA) {\r\n                return overallScoreB - overallScoreA;\r\n            }\r\n\r\n            //use allotment numbers as a tiebreaker\r\n            return a.currentAllotment - b.currentAllotment;\r\n        });\r\n\r\n        let selectedAdvisor = validAdvisors[0];\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n        caLeadsInCluster[selectedAdvisor.id].leadsInCluster[lead.cluster] = caLeadsInCluster[selectedAdvisor.id].leadsInCluster[lead.cluster] ? caLeadsInCluster[selectedAdvisor.id].leadsInCluster[lead.cluster] + 1 : 1;\r\n    }\r\n\r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocatePropensityAllotmentDifficultyBalancedProportional(leads, courseAdvisors, parameters) {\r\n    let updatedLeads = leads.slice();\r\n    let updatedCourseAdvisors = courseAdvisors.slice();\r\n\r\n    const propensityWeighting = Number(parameters[ALLOCATION_MODES.PropensityAllotmentDifficultyBalancedProportional.parameters.propensityWeighting.order]);\r\n    const allotmentWeighting = Number(parameters[ALLOCATION_MODES.PropensityAllotmentDifficultyBalancedProportional.parameters.allotmentWeighting.order]);\r\n    const difficultyWeighting = Number(parameters[ALLOCATION_MODES.PropensityAllotmentDifficultyBalancedProportional.parameters.difficultyWeighting.order]);\r\n    const decayPerDay = Number(parameters[ALLOCATION_MODES.PropensityAllotmentDifficultyBalancedProportional.parameters.decayPerDay.order]);\r\n    const cycleDecayDurationDays = Number(parameters[ALLOCATION_MODES.PropensityAllotmentDifficultyBalancedProportional.parameters.cycleDecayDurationDays.order]);\r\n    const decayPerCycle = Number(parameters[ALLOCATION_MODES.PropensityAllotmentDifficultyBalancedProportional.parameters.decayPerCycle.order]) / 100;\r\n    const simulationStartDate = leads[0].created.clone().startOf('date');\r\n\r\n    let lastDailyDecayDate = simulationStartDate.clone();\r\n    let lastCycleDecayDate = simulationStartDate.clone();\r\n    \r\n    let totalCumulativeInherentAtLead = 0;\r\n\r\n    for (let i = 0; i < leads.length; i++) {\r\n        let lead = updatedLeads[i];\r\n        let totalAllotment = 0;\r\n        let cumulativePropensity = 0;\r\n        let availableAdvisors = 0;\r\n        let currentDate = leads[i].created.clone().startOf('date');\r\n\r\n        totalCumulativeInherentAtLead = totalCumulativeInherentAtLead + lead.inherent;\r\n\r\n        lastDailyDecayDate = applyDecay(updatedCourseAdvisors, currentDate, lastCycleDecayDate, lastDailyDecayDate, cycleDecayDurationDays, decayPerCycle, decayPerDay);\r\n        \r\n        let validAdvisors = updatedCourseAdvisors.filter((advisor) => (isMatchingPortfolio(advisor, lead)));\r\n\r\n        for (let caNum = 0; caNum < validAdvisors.length; caNum++) {\r\n            let advisor = validAdvisors[caNum];\r\n            totalAllotment = totalAllotment + advisor.currentAllotment;\r\n            cumulativePropensity = cumulativePropensity + lead.courseAdvisors[advisor.id].propensity;\r\n            \r\n            let caIsInWorkingHours = isInWorkingHours(lead.created, updatedCourseAdvisors[advisor.id].location);\r\n            availableAdvisors = caIsInWorkingHours ? availableAdvisors + 1 : availableAdvisors;\r\n\r\n            validAdvisors[caNum] = {\r\n                ...advisor, \r\n                propensity: lead.courseAdvisors[advisor.id].propensity,\r\n                isInWorkingHours: caIsInWorkingHours,\r\n            }\r\n        }\r\n        \r\n        let averageAllotment;\r\n        let averagePropensity;\r\n        let averageInherent;\r\n        if (availableAdvisors > 0) {\r\n            averageAllotment = totalAllotment / availableAdvisors;\r\n            averagePropensity = cumulativePropensity / availableAdvisors;\r\n            averageInherent = totalCumulativeInherentAtLead / availableAdvisors;\r\n        }\r\n        else {\r\n            averageAllotment = totalAllotment / validAdvisors.length;\r\n            averagePropensity = cumulativePropensity / validAdvisors.length;\r\n            averageInherent = totalCumulativeInherentAtLead / validAdvisors.length;\r\n        }\r\n\r\n        validAdvisors.sort((a,b) => {\r\n            //give firm precedence to those who are currently working\r\n            if (b.isInWorkingHours && !a.isInWorkingHours) {\r\n                return 1;\r\n            }\r\n            if (a.isInWorkingHours && !b.isInWorkingHours) {\r\n                return -1;\r\n            }\r\n\r\n            //Otherwise choosing the CA with the best overall score\r\n            let overallScoreA = calculateOverallScoreWithDifficulty(a, averagePropensity, averageAllotment, averageInherent, propensityWeighting, allotmentWeighting, difficultyWeighting);\r\n            let overallScoreB = calculateOverallScoreWithDifficulty(b, averagePropensity, averageAllotment, averageInherent, propensityWeighting, allotmentWeighting, difficultyWeighting);\r\n            if (overallScoreB !== overallScoreA) {\r\n                return overallScoreB - overallScoreA;\r\n            }\r\n\r\n            //use allotment numbers as a tiebreaker\r\n            return a.currentAllotment - b.currentAllotment;\r\n        });\r\n\r\n        let selectedAdvisor = validAdvisors[0];\r\n        allocateLead(lead, selectedAdvisor, updatedCourseAdvisors);\r\n        updatedCourseAdvisors[selectedAdvisor.id].runningInherent += lead.inherent;\r\n    }\r\n\r\n    const returnObj = {\r\n        leads: updatedLeads,\r\n        courseAdvisors: updatedCourseAdvisors,\r\n    }\r\n    return returnObj;\r\n}\r\n\r\n\r\nfunction allocateLead(lead, selectedAdvisor, courseAdvisors) {\r\n    lead.allocatedCa = selectedAdvisor.id;\r\n    lead.allotmentAtAllocation = selectedAdvisor.currentAllotment + 1;\r\n    lead.assessedPropensity = lead.courseAdvisors[selectedAdvisor.id].assessedPropensity;\r\n    lead.allocatedPropensity = lead.courseAdvisors[selectedAdvisor.id].propensity;\r\n    courseAdvisors[selectedAdvisor.id].totalAllotment++;\r\n    courseAdvisors[selectedAdvisor.id].currentAllotment++;\r\n}\r\n\r\n\r\nfunction applyDecay(updatedCourseAdvisors, currentDate, lastCycleDecayDate, lastDailyDecayDate, cycleDecayDurationDays, decayPerCycle, decayPerDay) {\r\n    //Per cycle delay, ignore if the cycle is set to zero\r\n    let cycleDelayDays = currentDate.diff(lastCycleDecayDate, 'days');\r\n    if (cycleDecayDurationDays > 0 && cycleDelayDays >= cycleDecayDurationDays) {\r\n        let decayCyclesPassed = Math.floor(cycleDelayDays / cycleDecayDurationDays);\r\n        let totalDecayPercentage = decayPerCycle ** decayCyclesPassed;\r\n        for (let caNum = 0; caNum < updatedCourseAdvisors.length; caNum++) {\r\n            let advisor = updatedCourseAdvisors[caNum];\r\n            advisor.currentAllotment = advisor.currentAllotment * (1 - totalDecayPercentage);\r\n        }\r\n        lastCycleDecayDate.add(cycleDecayDurationDays * decayCyclesPassed, 'days');\r\n    }\r\n\r\n    //Per day delay\r\n    let dailyDecayDays = currentDate.diff(lastDailyDecayDate, 'days');\r\n    if (dailyDecayDays > 0) {\r\n        for (let caNum = 0; caNum < updatedCourseAdvisors.length; caNum++) {\r\n            let advisor = updatedCourseAdvisors[caNum];\r\n            let decayAmount = dailyDecayDays * decayPerDay * advisor.decayModifier;\r\n            advisor.currentAllotment = Math.max(advisor.currentAllotment - decayAmount, 0);\r\n        }\r\n        lastDailyDecayDate = currentDate.clone();\r\n    }\r\n    return lastDailyDecayDate;\r\n}\r\n\r\nfunction calculateOverallScore(advisor, averagePropensity, averageAllotment, propensityWeighting, allotmentWeighting) {\r\n    let propensityScore = averagePropensity > 0 ? (advisor.propensity - averagePropensity) / averagePropensity * propensityWeighting : 0;\r\n    let allotmentScore = (averageAllotment - advisor.currentAllotment) * allotmentWeighting\r\n    return propensityScore + allotmentScore;\r\n}\r\n\r\nfunction calculateOverallScoreClustered(advisor, averagePropensity, averageAllotment, propensityWeighting, allotmentWeighting) {\r\n    let propensityScore = averagePropensity > 0 ? (advisor.propensity - averagePropensity) / averagePropensity * propensityWeighting : 0;\r\n    let allotmentScore = (averageAllotment - advisor.leadsInCluster) * allotmentWeighting\r\n    return propensityScore + allotmentScore;\r\n}\r\n\r\nfunction calculateOverallScoreWithDifficulty(advisor, averagePropensity, averageAllotment, averageInherent, propensityWeighting, allotmentWeighting, difficultyWeighting) {\r\n    let propensityScore = averagePropensity > 0 ? (advisor.propensity - averagePropensity) / averagePropensity * propensityWeighting : 0;\r\n    let allotmentScore = (averageAllotment - advisor.currentAllotment) * allotmentWeighting\r\n    let difficultyScore = averageInherent > 0 ? (advisor.runningInherent - averageInherent / averageInherent) * difficultyWeighting : 0;\r\n    return propensityScore + allotmentScore - difficultyScore;\r\n}\r\n\r\nfunction isMatchingPortfolio(advisor, lead) {\r\n    return advisor.portfolio === lead.portfolio;\r\n}\r\n\r\nfunction isInWorkingHours(datetime, location) {\r\n    let timezone = TIMEZONES[location];\r\n    let hourOfDay = datetime.hour() + datetime.minute() / 60;\r\n\r\n    //Return false for anything falling on a Saturday or Sunday\r\n    let dayOfWeek = datetime.clone().subtract(timezone.timezoneOffsetFromAdelaide, 'hours').day();\r\n    if (dayOfWeek === 0 || dayOfWeek === 6) {\r\n        return false;\r\n    }\r\n    \r\n    let effectiveEndHour = timezone.endHour;\r\n    let effectiveHourOfDay = hourOfDay;\r\n    if (timezone.endHour <= timezone.startHour) {\r\n        effectiveEndHour = timezone.endHour + 24;\r\n        if (hourOfDay < timezone.startHour) {\r\n            effectiveHourOfDay += 24;\r\n        }\r\n    }\r\n\r\n    return effectiveHourOfDay >= timezone.startHour && effectiveHourOfDay <= effectiveEndHour;\r\n}","import { ALLOCATION_MODES } from './AllocationUtils';\r\n\r\nfunction ConfigPanel(props) {\r\n\r\n    let allocationModeOptionElements = [<option key=\"unselected\" value={null} hidden/>]\r\n    allocationModeOptionElements = allocationModeOptionElements.concat(Object.keys(ALLOCATION_MODES).map((mode) => \r\n        <option key={ALLOCATION_MODES[mode].name} value={mode}>\r\n            {ALLOCATION_MODES[mode].name}\r\n        </option>));\r\n\r\n    let inputParameters = [];\r\n    if (props.selectedMode && props.selectedMode.parameters) {\r\n        const parameters = Object.keys(props.selectedMode.parameters);\r\n        for (let i = 0; i < parameters.length; i++) {\r\n            let currentParameter = props.selectedMode.parameters[parameters[i]];\r\n            inputParameters[i] = <div key={parameters[i]}>\r\n                <label htmlFor={parameters[i]}>{currentParameter.label}</label>\r\n                <input\r\n                    name={parameters[i]}\r\n                    type=\"number\"\r\n                    step=\"any\"\r\n                    onChange={(e) => props.onParameterChange(e, currentParameter.order)}\r\n                />\r\n            </div>\r\n        }\r\n    }\r\n        \r\n\r\n    return (\r\n        <div>\r\n            <select\r\n                onChange={(e) => props.onModeChange(e.target.value)}\r\n            >\r\n                {allocationModeOptionElements}\r\n            </select>\r\n            <div>\r\n                {props.selectedMode ? props.selectedMode.description : \"\"}\r\n            </div>\r\n            {inputParameters}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default ConfigPanel;","import React from 'react';\r\nimport { useTable } from 'react-table';\r\n\r\nexport function Table({ columns, data }) {\r\n    // Use the state and functions returned from useTable to build your UI\r\n    const {\r\n        getTableProps,\r\n        getTableBodyProps,\r\n        headerGroups,\r\n        rows,\r\n        prepareRow,\r\n    } = useTable({\r\n        columns,\r\n        data,\r\n    });\r\n\r\n    // Render the UI for your table\r\n    return (\r\n        <table {...getTableProps()}>\r\n            <thead>\r\n                {headerGroups.map(headerGroup => (\r\n                    <tr {...headerGroup.getHeaderGroupProps()}>\r\n                        {headerGroup.headers.map(column => (\r\n                            <th {...column.getHeaderProps()}>{column.render('Header')}</th>\r\n                        ))}\r\n                    </tr>\r\n                ))}\r\n            </thead>\r\n            <tbody {...getTableBodyProps()}>\r\n                {rows.map((row, i) => {\r\n                    prepareRow(row);\r\n                    return (\r\n                        <tr {...row.getRowProps()}>\r\n                            {row.cells.map(cell => {\r\n                                return <td {...cell.getCellProps()}>{cell.render('Cell')}</td>;\r\n                            })}\r\n                        </tr>\r\n                    );\r\n                })}\r\n            </tbody>\r\n        </table>\r\n    );\r\n}\r\n","import { Table } from './Table';\r\nimport React from 'react';\r\n\r\nconst PERCENT_FORMAT_PARAMS = {style: 'percent', maximumFractionDigits: 2};\r\n\r\nfunction ResultsPanel(props) {\r\n\r\n    const CA_RESULTS_TABLE_COLUMNS = React.useMemo(\r\n        () => [\r\n            {\r\n                Header: 'CA',\r\n                accessor: 'caName',\r\n            },\r\n            {\r\n                Header: 'Portfolio',\r\n                accessor: 'portfolio'\r\n            },\r\n            {\r\n                Header: 'Location',\r\n                accessor: 'location'\r\n            },\r\n            {\r\n                Header: 'Total Allotment',\r\n                accessor: 'totalAllotment',\r\n            },\r\n            {\r\n                Header: 'Final Allotment',\r\n                accessor: 'currentAllotment',\r\n            },\r\n            {\r\n                Header: 'Average Propensity',\r\n                accessor: (row) => row ? row.averagePropensity.toLocaleString(undefined, PERCENT_FORMAT_PARAMS) : 0,\r\n            },\r\n            {\r\n                Header: 'Variance to Inherent',\r\n                accessor: (row) => row ? row.varianceToInherent.toLocaleString(undefined, PERCENT_FORMAT_PARAMS) : 0,\r\n            },\r\n            {\r\n                Header: 'Predicted Conversions',\r\n                accessor: (row) => row ? row.predictedConversions.toFixed(2) : 0,\r\n            },\r\n        ],\r\n        []\r\n    )\r\n    \r\n    const OVERALL_RESULTS_TABLE_COLUMNS = React.useMemo(\r\n        () => [\r\n            {\r\n                Header: 'Total Leads',\r\n                accessor: 'totalLeads',\r\n            },\r\n            {\r\n                Header: 'Average Propensity',\r\n                accessor: (row) => row ? row.averagePropensity.toLocaleString(undefined, PERCENT_FORMAT_PARAMS) : 0,\r\n            },\r\n            {\r\n                Header: 'Average Variance to Inherent',\r\n                accessor: (row) => row ? row.averageVarianceToInherent.toLocaleString(undefined, PERCENT_FORMAT_PARAMS) : 0,\r\n            },\r\n            {\r\n                Header: 'Predicted Conversions',\r\n                accessor: (row) => row ? row.predictedConversions.toFixed(2) : 0,\r\n            },\r\n        ],\r\n        []\r\n    )\r\n\r\n\r\n    return (\r\n        <div>\r\n            <h3>Aggregated Results</h3>\r\n            <Table columns={OVERALL_RESULTS_TABLE_COLUMNS} data={props.aggregatedResults ? [props.aggregatedResults] : []}/>\r\n            <h3>Individual CA Results</h3>\r\n            <Table columns={CA_RESULTS_TABLE_COLUMNS} data={props.courseAdvisors ? props.courseAdvisors : []}/>\r\n        </div>\r\n    );\r\n}\r\n\r\n\r\nexport default ResultsPanel;","import LocalFileReader from './LocalFileReader';\r\nimport { CSVDownloader } from 'react-papaparse'\r\nimport ConfigPanel from './ConfigPanel';\r\nimport React, {useState} from 'react';\r\nimport moment from 'moment';\r\n\r\nimport {ALLOCATION_MODES} from './AllocationUtils';\r\nimport ResultsPanel from './ResultsPanel';\r\n\r\nfunction LeadAllocationHome() {\r\n    const [leadData, setLeadData] = useState();\r\n    const [courseAdvisors, setCourseAdvisors] = useState();\r\n    const [selectedMode, setSelectedMode] = useState();\r\n    const [aggregatedResults, setAggregatedResults] = useState();\r\n    const [inputParameters, setInputParameters] = useState();\r\n    const [leadExportData, setLeadExportData] = useState();\r\n    const [resultSummaryExportData, setResultSummaryExportData] = useState();\r\n\r\n    const DATE_FORMAT = \"YYYY-MM-DDTHH:MMZ\";\r\n\r\n\r\n    let handleCaDataLoad = (e) => {\r\n        let newCourseAdvisors = [];\r\n\r\n        for (let rowNum = 0; rowNum < e.length; rowNum++) {\r\n            let row = e[rowNum].data;\r\n            let newCa = {\r\n                id: row.id,\r\n                caName: row.name,\r\n                portfolio: row.portfolio,\r\n                location: row.location,\r\n                decayModifier: row.decayModifier,\r\n                allotmentLimit: row.allotmentLimit ? row.allotmentLimit : 0,\r\n                overallPropensity: row.overallPropensity ? row.overallPropensity : 0,\r\n                totalAllotment: 0,\r\n                currentAllotment: 0,\r\n                cumulativePropensity: 0,\r\n                runningInherent: 0, //hacky, used to count the cumulative inherent through the sim as opposed to cumulativeInherent as the result summary value \r\n                cumulativeInherent: 0,\r\n                averagePropensity: 0,\r\n                varianceToInherent: 0,\r\n                predictedConversions: 0,\r\n            }\r\n            newCourseAdvisors[rowNum] = newCa;\r\n        }\r\n\r\n        setCourseAdvisors(newCourseAdvisors);\r\n    }   \r\n\r\n    let handleLeadDataLoad = (e) => {\r\n        let leads = [];\r\n        for (let rowNum = 0; rowNum < e.length; rowNum++) {\r\n            let row = e[rowNum].data;\r\n            let newLead = {\r\n                leadId: row.leadId,\r\n                salesforceId: row.Id,\r\n                created: moment(row.created, DATE_FORMAT),\r\n                cluster: row.cluster,\r\n                inherent: row.inherent,\r\n                portfolio: row.portfolio,\r\n            };\r\n\r\n            newLead.courseAdvisors = [];\r\n            let caNum = 0;\r\n            for (let fieldNum = 0; fieldNum < e[rowNum].meta.fields.length; fieldNum++) {\r\n                if (courseAdvisors.some(v => v.caName === e[rowNum].meta.fields[fieldNum])) {\r\n                    let newCa = {\r\n                        id: caNum,\r\n                        caName: e[rowNum].meta.fields[fieldNum],\r\n                        propensity: courseAdvisors[caNum].overallPropensity ? courseAdvisors[caNum].overallPropensity : row[e[rowNum].meta.fields[fieldNum]],\r\n                        assessedPropensity: row[e[rowNum].meta.fields[fieldNum]],\r\n                    }\r\n                    newLead.courseAdvisors.push(newCa);\r\n                    caNum++;\r\n                }\r\n            }\r\n            leads[rowNum] = newLead;\r\n        }\r\n        setLeadData(leads);\r\n    } \r\n\r\n    let handleFileRemove = () => {\r\n        setLeadData();\r\n        setCourseAdvisors();\r\n        setAggregatedResults();\r\n        setInputParameters();\r\n        setLeadExportData();\r\n    }\r\n\r\n    let handleModeChange = (selectedMode) => {\r\n        setInputParameters();\r\n        setSelectedMode(ALLOCATION_MODES[selectedMode]);\r\n    }\r\n\r\n    let handleParameterChange = (e, parameterOrder) => {\r\n        let updatedInputParameters = inputParameters ? inputParameters.slice() : [];\r\n        if (e.target.value) {\r\n            updatedInputParameters[parameterOrder] = e.target.value;\r\n        } \r\n        else {\r\n            updatedInputParameters.splice(parameterOrder);\r\n        }\r\n\r\n        setInputParameters(updatedInputParameters);\r\n    }\r\n\r\n    let runSimulation = () => {\r\n        const result = generateResults(selectedMode.allocationFunction(leadData, courseAdvisors, inputParameters));\r\n\r\n        setLeadData(result.leads);\r\n        setCourseAdvisors(result.courseAdvisors);\r\n        setAggregatedResults(result.aggregatedResults);\r\n        setLeadExportData(result.leadExportData);\r\n        setResultSummaryExportData(result.resultSummaryExportData);\r\n    }\r\n\r\n    let generateResults = (result) =>  {\r\n        let updatedCourseAdvisors = result.courseAdvisors.slice();\r\n        for (let leadNum = 0; leadNum < result.leads.length; leadNum++) {\r\n            let lead = result.leads[leadNum];\r\n            let allocatedCa = updatedCourseAdvisors[lead.allocatedCa];\r\n            let selectedPropensity = lead.courseAdvisors[allocatedCa.id].assessedPropensity;\r\n            allocatedCa.cumulativePropensity = allocatedCa.cumulativePropensity + selectedPropensity;\r\n            allocatedCa.cumulativeInherent = allocatedCa.cumulativeInherent + lead.inherent;\r\n        }\r\n\r\n        let aggregatedResults = {\r\n            totalLeads: 0,\r\n            cumulativePropensity: 0,\r\n            cumulativeInherent: 0,\r\n            averagePropensity: 0,\r\n            averageVarianceToInherent: 0,\r\n            predictedConversions: 0,\r\n        }\r\n        for (let caNum = 0; caNum < updatedCourseAdvisors.length; caNum++) {\r\n            let advisor = updatedCourseAdvisors[caNum];\r\n            advisor.averagePropensity = advisor.totalAllotment ? advisor.cumulativePropensity / advisor.totalAllotment : 0;\r\n            advisor.varianceToInherent = advisor.cumulativeInherent ? (advisor.cumulativePropensity / advisor.cumulativeInherent) - 1 : 0;\r\n            advisor.predictedConversions = advisor.totalAllotment * advisor.averagePropensity;\r\n\r\n            aggregatedResults.totalLeads += advisor.totalAllotment;\r\n            aggregatedResults.cumulativePropensity += advisor.cumulativePropensity;\r\n            aggregatedResults.cumulativeInherent += advisor.cumulativeInherent;\r\n            aggregatedResults.predictedConversions += advisor.predictedConversions;\r\n        }\r\n        aggregatedResults.averagePropensity = aggregatedResults.cumulativePropensity / aggregatedResults.totalLeads;\r\n        aggregatedResults.averageVarianceToInherent = (aggregatedResults.cumulativePropensity / aggregatedResults.cumulativeInherent) - 1;\r\n\r\n        let updatedResult = {...result};\r\n        updatedResult.courseAdvisors = updatedCourseAdvisors;\r\n        updatedResult.aggregatedResults = aggregatedResults;\r\n\r\n        updatedResult = generateExportData(updatedResult);\r\n\r\n        return updatedResult;\r\n    }\r\n\r\n\r\n    let generateExportData = (result) => {\r\n        let adjustedLeads = leadData.slice().map((lead) => {\r\n            let newLead = {...lead};\r\n            newLead.created = newLead.created.format(DATE_FORMAT);\r\n            newLead.allocatedCa = courseAdvisors[newLead.allocatedCa].caName;\r\n            delete newLead.courseAdvisors;\r\n\r\n            return newLead;\r\n        });\r\n\r\n        let updatedResult = {...result};\r\n        updatedResult.leadExportData = adjustedLeads;\r\n\r\n        let resultSummary = courseAdvisors.slice().map((advisor) => {\r\n            return {\r\n                name: advisor.caName,\r\n                id: advisor.id,\r\n                portfolio: advisor.portfolio,\r\n                location: advisor.location,\r\n                totalAllotment: advisor.totalAllotment,\r\n                finalAllotment: advisor.currentAllotment,\r\n                averagePropensity: advisor.averagePropensity,\r\n                varianceToInherent: advisor.varianceToInherent,\r\n                predictedConversions: advisor.predictedConversions,\r\n                unmodelledPropensityUsed: advisor.overallPropensity ? advisor.overallPropensity : \"-\",\r\n            }\r\n        });\r\n\r\n        resultSummary.push({\r\n            name: \"Total\",\r\n            totalAllotment: result.aggregatedResults.totalLeads,\r\n            averagePropensity: result.aggregatedResults.averagePropensity,\r\n            varianceToInherent: result.aggregatedResults.averageVarianceToInherent,\r\n            predictedConversions: result.aggregatedResults.predictedConversions,\r\n        });\r\n\r\n        updatedResult.resultSummaryExportData = resultSummary;\r\n\r\n        return updatedResult;\r\n    }\r\n\r\n\r\n    let getExportFilename = (type) => {\r\n        let filename = \"invalid-nodata\"\r\n        if (aggregatedResults && selectedMode) {\r\n            filename = Object.keys(ALLOCATION_MODES)[selectedMode.id] + \"-\" + type + \"-\" + moment().format(\"YYYYMMDD-HHMMss\")\r\n        }\r\n        return filename;\r\n    }\r\n\r\n\r\n\r\n    return (\r\n        <div className=\"App\">\r\n            <header className=\"App-header\">\r\n                <h3>CA File</h3>\r\n                <LocalFileReader\r\n                // CA Data\r\n                    onFileLoad={(e) => handleCaDataLoad(e)}\r\n                    onFileRemove={() => handleFileRemove()}\r\n                />\r\n                <h3>Lead File</h3>\r\n                <LocalFileReader\r\n                // Lead Data\r\n                    onFileLoad={(e) => handleLeadDataLoad(e)}\r\n                    onFileRemove={() => handleFileRemove()}\r\n                    disabled={!(courseAdvisors && courseAdvisors.length > 0)}\r\n                />\r\n                <ConfigPanel\r\n                    selectedMode={selectedMode}\r\n                    onModeChange={(e) => handleModeChange(e)}\r\n                    onParameterChange={(e, parameter) => handleParameterChange(e, parameter)}\r\n                />\r\n                <button\r\n                    onClick={() => runSimulation()}\r\n                    disabled={!leadData || !selectedMode || \r\n                        (selectedMode.parameters && (!inputParameters || inputParameters.length < Object.keys(selectedMode.parameters).length))}\r\n                >\r\n                    Run Simulation\r\n                </button>\r\n                <CSVDownloader\r\n                    data={leadExportData}\r\n                    type={\"button\"}\r\n                    filename={getExportFilename(\"LeadAllocation\")}\r\n                    bom={false}\r\n                >\r\n                    Export Lead Allocations\r\n                </CSVDownloader>\r\n                <CSVDownloader\r\n                    data={resultSummaryExportData}\r\n                    type={\"button\"}\r\n                    filename={getExportFilename(\"ResultSummary\")}\r\n                    bom={false}\r\n                >\r\n                    Export Result Summary\r\n                </CSVDownloader>\r\n                <ResultsPanel\r\n                    courseAdvisors={courseAdvisors}\r\n                    aggregatedResults={aggregatedResults}\r\n                />\r\n            </header>\r\n        </div>\r\n    );\r\n}\r\n\r\n\r\n\r\nexport default LeadAllocationHome;\r\n\r\n\r\n\r\n/*\r\nAllocation Mode: manual, round robin, linear weighted, polynomial weighted, optimised round robin (leeway of n)\r\nInput data (csv load)\r\nRandomise order\r\nAuto-allocate\r\n\r\nSummaries: overall result score (raw conversions, variance to inherent)\r\n\r\nIndividual leads (allocated CA [freeze], inherent, per CA propensity)\r\n\r\n*/","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport LeadAllocationHome from './LeadAllocationHome';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <LeadAllocationHome />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}